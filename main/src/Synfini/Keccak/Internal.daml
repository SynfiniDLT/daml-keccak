-- Copyright (c) 2023 ASX Operations Pty Ltd. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Synfini.Keccak.Internal (
  keccak_f,
  KeccakSettings,
  keccakSettings,
  zeroState,
  preset
) where

import qualified DA.Action.State.Class as S
import Synfini.Keccak.Internal.Data
import DA.Foldable (sequence_, forA_, toList, Foldable, mapA_)
import qualified DA.Action.State as S
import DA.Math (logBase)
import DA.Action (replicateA)
import qualified DA.Text as TX

bitsToBytes : Int -> Int
bitsToBytes x = (x + 7) / 8

data KeccakSettings = KeccakSettings
  with
    bitrate : Int
    b : Int
    bitrateBytes : Int
    laneW : Int
    outputBits : Int

stateW : Int
stateW = 5

rangeW : [Int]
rangeW = [0..stateW - 1]

stateH : Int
stateH = 5

rangeH : [Int]
rangeH = [0..stateH - 1] 

rangeWH : [(Int, Int)]
rangeWH = do
  x <- rangeW
  y <- rangeH
  pure (x, y)

zeroState : Matrix Lane
zeroState = listToVector (replicate stateH (listToVector (replicate stateW zeroLane)))

-- Generate keccak settings (will fail on invalid settings)
keccakSettings : Int  -> Int -> Int -> KeccakSettings
keccakSettings bitrateBits capacityBits outputBits =
  let mk = do
        let b = bitrateBits + capacityBits
        assertMsg "must have an accepted number of bits" (b `elem` [25, 50, 100, 200, 500, 800, 1600])
        assertMsg "output bits must be a whole number of bytes" (outputBits `mod` 8 == 0)
        assertMsg "bit rate must be a multiple of 8" (bitrateBits `mod` 8 == 0)
        assertMsg "b must be a multiple of 25" (b `mod` 25 == 0)
        pure KeccakSettings with
          bitrate = bitrateBits
          b
          bitrateBytes = bitsToBytes bitrateBits
          laneW = b / 25
          outputBits
  in
  case mk of
    Left err -> error ("Keccak: Invalid keccak settings: " <> err)
    Right s -> s

type KeccakAction a = (Action a, S.ActionState (Matrix Lane) a)

(<--) : KeccakAction a => (Int, Int) -> Lane -> a ()
(x, y) <-- l = S.modify (updateMatrix x y l)
infixl 3 <--

(<--^) : KeccakAction a => (Int, Int) -> Lane -> a ()
(x, y) <--^ u = do
  l <- getLane (x, y)
  (x, y) <-- l `xor` u
infixl 3 <--^

getRow : KeccakAction a => Int -> a (Vector Lane)
getRow r = do
  s <- S.get
  pure (s # r)

getLane : KeccakAction a => (Int, Int) -> a Lane
getLane pos = do
  s <- S.get
  pure (s ## pos)

multiratePadding : Int -> Int -> Vector Byte
multiratePadding usedBytes alignBytes =
  let l = alignBytes - usedBytes in
  let padlen = if l == 0 then alignBytes else l in
  listToVector $
    if padlen == 1 then
      [0x81]
    else
      [0x01] <> replicate (padlen - 2) 0x00 <> [0x80]

doKeccak : forall a. KeccakAction a =>
           KeccakSettings ->
           (Int -> Int -> Vector Byte) ->
           (Int -> a ()) ->
           Text ->
           a Text
doKeccak ks padfn permfn input = do
  let buffer = textToBytes input
  spongeAbsorb buffer
  let finalBufferOffset = vectorSize buffer - ((vectorSize buffer) `mod` ks.bitrateBytes)
  hashBytes <- hashDigest finalBufferOffset buffer
  pure . TX.asciiToLower . TX.implode $ byteToHex <$> vectorToList hashBytes

  where
    absorb : Int -> Vector Byte -> a ()
    absorb offset bb = do
      let findInBb idx = if idx >= ks.bitrateBytes then 0 else bb # (idx + offset)

      sequence_ do
        y <- rangeH
        x <- rangeW
        let i = (y * stateH + x) * 8
        pure do
          (x, y) <--^ bytesToLane (findInBb <$> [i..i+7])

    hashDigest : Int -> Vector Byte -> a (Vector Byte)
    hashDigest offset buffer = do
      spongeAbsorbFinal offset buffer
      spongeSqueeze (bitsToBytes ks.outputBits)

    getBytes : Int -> a (Vector Byte)
    getBytes lim = do
      l <- sequence do
        y <- rangeH
        x <- rangeW
        pure do
          lane <- getLane (x, y)
          pure $ laneToBytes ks.laneW lane
      pure . listToVector . take lim $ concat l

    spongeAbsorb : Vector Byte -> a ()
    spongeAbsorb buffer = do
      forA_ [0,ks.bitrateBytes..(vectorSize buffer - ks.bitrateBytes)] $ \offset -> do
        spongeAbsorbBlock offset buffer

    spongeAbsorbBlock : Int -> Vector Byte -> a ()
    spongeAbsorbBlock offset bb = do
      absorb offset bb
      permfn ks.laneW

    spongeAbsorbFinal : Int -> Vector Byte -> a ()
    spongeAbsorbFinal offset buffer = do
      let padded = concatVectors [
              dropVector offset buffer,
              padfn (vectorSize buffer - offset) ks.bitrateBytes
            ]
      spongeAbsorbBlock 0 padded

    spongeSqueeze : Int -> a (Vector Byte)
    spongeSqueeze l = do
      let iters = l / ks.bitrateBytes + (if l `mod` ks.bitrateBytes == 0 then 0 else 1)
      z <- fmap concatVectors . replicateA iters $ spongeSqueezeOnce
      pure (takeVector l z)

    spongeSqueezeOnce : a (Vector Byte)
    spongeSqueezeOnce = do
      rc <- getBytes ks.bitrateBytes
      permfn ks.laneW
      pure rc

roundConstants : [Lane]
roundConstants = [
    0x0000000000000001, 0x0000000000008082, minBound + 0x00000000000808A, minBound + 0x000000080008000,
    0x000000000000808B, 0x0000000080000001, minBound + 0x000000080008081, minBound + 0x000000000008009,
    0x000000000000008A, 0x0000000000000088, 0x0000000080008009, 0x000000008000000A,
    0x000000008000808B, minBound + 0x00000000000008B, minBound + 0x000000000008089, minBound + 0x000000000008003,
    minBound + 0x000000000008002, minBound + 0x000000000000080, 0x000000000000800A, minBound + 0x00000008000000A,
    minBound + 0x000000080008081, minBound + 0x000000000008080, 0x0000000080000001, minBound + 0x000000080008008
  ]

rotationConstants : Matrix Int
rotationConstants =
  let arr = [
          [  0,  1, 62, 28, 27 ],
          [ 36, 44,  6, 55, 20 ],
          [  3, 10, 43, 25, 39 ],
          [ 41, 45, 15, 21,  8 ],
          [ 18,  2, 61, 56, 14 ]
        ]
  in
  listToVector (listToVector <$> arr)

reduce : Foldable t => (a -> a -> a) -> t a -> a
reduce f t =
  let l = toList t in
  case l of
    x :: xs -> foldl f x xs
    [] -> error "Keccak: Internal error: Unexpected empty list"

mod : Int -> Int -> Int
num `mod` denom =
  let rem = num % denom in
  if num >= 0 then
    rem
  else
    denom + rem

keccak_f : forall a. KeccakAction a => Int -> a ()
keccak_f laneW = do
  -- In daml, decimal values are not represened as binary numbers, therefore taking log in base 2 is not always 100%
  -- accurate - e.g. logBase 2.0 64.0 == 5.9999999997. As a work around we add a small value to the log result to
  -- account for this issue.
  let l = floor (logBase 2.0 (intToDecimal laneW) + 10.0^(-9))
  mapA_ doRound (take (12 + 2 * l) roundConstants)

  where
    doRound : Lane -> a ()
    doRound rc = do
      c : Vector Lane <- fmap listToVector . forA rangeH $ \x -> do
        r <- getRow x
        pure $ reduce xor r
      let d : Vector Lane = listToVector do
            x <- rangeW
            pure $
              (c # ((x - 1) `mod` stateW)) `xor`
              (rol (c # ((x + 1) `mod` stateW)) 1 laneW)
      forA_ rangeWH $ \(x, y) -> do
        (x, y) <--^ (d # x)
      bElems <- forA rangeWH $ \(x, y) -> do
        lane <- getLane (x, y)
        pure (
            (y `mod` stateW, (2 * x + 3 * y) `mod` stateH),
            rol lane (rotationConstants ## (y, x)) laneW
          )
      -- Matrix elements are zero by default, or use those in bElems if they are provided
      let b : Matrix Lane = listToMatrix (matrixToList zeroState <> bElems)
      forA_ rangeWH $ \(x, y) -> do
        (x, y) <-- (b ## (x, y)) `xor`
          ((inv (b ## ((x + 1) `mod` stateW, y))) & (b ## ((x + 2) `mod` stateW, y)))
      (0, 0) <--^ rc

preset : KeccakSettings -> Text -> Text
preset ks input = S.evalState (doKeccak ks multiratePadding keccak_f input) zeroState
