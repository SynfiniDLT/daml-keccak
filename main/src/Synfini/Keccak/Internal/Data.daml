{-# LANGUAGE BinaryLiterals #-}

module Synfini.Keccak.Internal.Data (
  Vector,
  Matrix,
  vectorSize,
  listToVector,
  concatVectors,
  dropVector,
  takeVector,
  vectorToList,
  listToMatrix,
  matrixToList,
  updateMatrix,
  (#),
  (##),
  xor,
  rol,
  inv,
  (&),
  Lane, --(..),
  Byte,
  zeroLane,
  bytesToLane,
  laneToBytes,
  textToBytes,
  byteToHex
) where

import qualified DA.List as L
import DA.Map (Map)
import qualified DA.Optional as O
import qualified DA.Map as Map
import qualified DA.Text as TX

zipChecked : [a] -> [b] -> [(a, b)]
zipChecked x y =
  if length x /= length y then
    error "zipChecked: list lengths are not equal"
  else
    zip x y

zipWithChecked : (a -> b -> c) -> [a] -> [b] -> [c]
zipWithChecked f x y =
  if length x /= length y then
    error "zipWithChecked: list lengths are not equal"
  else
    zipWith f x y

type Vector a = Map Int a

type Matrix a = Vector (Vector a)

vectorSize : Vector a -> Int
vectorSize = Map.size

listToVector : [a] -> Vector a
listToVector l = Map.fromList (zip [0..length l - 1] l)

vectorToList : Vector a -> [a]
vectorToList = fmap snd . Map.toList

takeVector : Int -> Vector a -> Vector a
takeVector n v = listToVector (fmap snd . take n $ Map.toList v)

dropVector : Int -> Vector a -> Vector a
dropVector n v = listToVector (fmap snd . drop n $ Map.toList v)

concatVectors : [Vector a] -> Vector a
concatVectors vs = listToVector . fmap snd $ concatMap Map.toList vs

updateMatrix : Int -> Int -> a -> Matrix a -> Matrix a
updateMatrix x y v = Map.alter u x
  where
    u None = Some $ Map.fromList [(y, v)]
    u (Some r) = Some $ Map.insert y v r

listToMatrix : [((Int, Int), a)] -> Matrix a
listToMatrix l = foldl addElem Map.empty l
  where
    addElem m ((x, y), value) = Map.alter (addElemInRow y value) x m

    addElemInRow y value None = Some (Map.fromList [(y, value)])
    addElemInRow y value (Some row) = Some (Map.insert y value row)

matrixToList : Matrix a -> [((Int, Int), a)]
matrixToList m = do
  (x, row) <- Map.toList m
  (y, value) <- Map.toList row
  pure ((x, y), value)

(#) : Vector a -> Int -> a
m # k = O.fromSomeNote ("Vector element not found at index: " <> show k) (Map.lookup k m)
infixl 3 #

(##) : Matrix a -> (Int, Int) -> a
m ## (x, y) = (m # x) # y
infixl 3 ##

-- Binary values where the most significant bit is the first element in the list
type Lane = Int

laneSize : Int
laneSize = 64

type Byte = Int

zeroLane : Lane
zeroLane = 0

pad : Int -> [Bool] -> [Bool]
pad n l =
  let lenDiff = length l - n in
  if lenDiff >= 0 then
    drop lenDiff l
  else
    replicate (-lenDiff) False <> l

-- Returns all permutations of bits of length n in ascending order:
-- 0...00, 0...01, 0...10, 00...11, ..., 1...1
bitPermutations : Int -> [[Bool]]
bitPermutations n | n <= 0 = []
bitPermutations 1 = [[False], [True]]
bitPermutations n =
  let p = bitPermutations (n - 1) in
  ((False ::) <$> p) <> ((True ::) <$> p)

nibblePermutations : [[Bool]]
nibblePermutations = bitPermutations 4

bytePermutations : [[Bool]]
bytePermutations = bitPermutations 8

hexUniChars : [Int]
hexUniChars = [48..57] <> -- 0 to 9
  [65..70] -- A to F
charBoolMap : Map Int [Bool]
charBoolMap = Map.fromList (zipChecked hexUniChars nibblePermutations)

byteValues : [Byte]
byteValues = [0..(2^8 - 1)]
byteBoolMap : Map Byte [Bool]
byteBoolMap =
  Map.fromList (zipChecked byteValues bytePermutations)

xor : Lane -> Lane -> Lane
l `xor` m = bitsToInt $ zipWithChecked xorBits (intToBits l) (intToBits m)

  where
    xorBits True False = True
    xorBits False True = True
    xorBits _ _ = False

one : Lane
one = 1

-- masks : Vector Lane
-- masks = listToVector $ ((\i -> (1 `shiftl` i) - 1) <$> [0..62]) <> [(-1)]

masks : Vector Lane
masks = listToVector $ (\i -> (-1) `shiftr` i) <$> [64,63..0] 

rol : Lane -> Int -> Int -> Lane
rol value left bits =
  let top = value `shiftr` (bits - left) in
  let bot = (value & (masks # (bits - left))) `shiftl` left in
  bot |. top

inv : Lane -> Lane
inv l = -l - 1

go : Int -> Int -> [Bool] -> [Bool]
go n a acc
  | n < 0 = acc
  | a >= 2^n = go (n - 1) (a - 2^n) (True :: acc)
  | otherwise = go (n - 1) a (False :: acc)

intToBits : Lane -> [Bool]
intToBits x =
  let firstBit = x < 0 in
  let x' = if firstBit then x + maxBound + 1 else x in
  firstBit :: reverse (go 62 x' [])

bitsToInt : [Bool] -> Lane
bitsToInt bits =
  let firstInt = if L.head bits then minBound else 0 in
  fst $ foldl (\(acc, i) bit -> ((if bit then 2^i else 0) + acc, i - 1)) (firstInt, 62) (L.tail bits)

(&) : Lane -> Lane -> Lane
a & b  = bitsToInt $ zipWithChecked (&&) (intToBits a) (intToBits b)

(|.) : Lane -> Lane -> Lane
a |. b = bitsToInt $ zipWithChecked (||) (intToBits a) (intToBits b)

shiftr : Lane -> Int -> Lane
a `shiftr` n
  | n <= 0 = a
  | n >= 64 = 0
  | a < 0 = (((a + maxBound + 1) / 2) `shiftr` (n - 1)) + 2^(63 - n)
  | otherwise  = (a / 2) `shiftr` (n - 1)

shiftl : Lane -> Int -> Lane
a `shiftl` n
  | n <= 0 = a
  | n >= 64 = 0
  | a >= 2^62 = (((a - 2^62) * 2) `shiftl` (n - 1)) + (if n == 1 then minBound else 0)
  | a < 0 = (a + maxBound + 1) `shiftl` n
  | otherwise = (a * 2) `shiftl` (n - 1)

bytesToLane : [Byte] -> Lane
bytesToLane bytes = sum $ zipWith (\byte i -> byte `shiftl` i) bytes [0,8..64]

chunksOf : Int -> [a] -> [[a]]
chunksOf n [] = []
chunksOf n l = take n l :: chunksOf n (drop n l)

laneToBytes : Int -> Lane -> [Byte]
laneToBytes w l = map (\i -> (l `shiftr` i) & 0xFF) [0,8..(w - 8)]

textToBytes : Text -> Vector Byte
textToBytes = listToVector . concatMap charToUtf8Bytes . TX.toCodePoints
  -- where
  --   codePointToBytes : Int -> [Byte]
  --   codePointToBytes n | n < 0 || n >= 2^24 = error ("Not a supported unicode character: " <> show n)
  --   codePointToBytes n =
  --     let byte0 = successiveMod n [62,61..8] in
  --     let byte1 = successiveMod (n - byte0) [62,61..16] in
  --     let byte2 = successiveMod (n - byte0 - byte1) [62,61..24] in
  --     dropWhile (== 0) [byte2 / (2 ^ 16), byte1 / (2 ^ 8), byte0]

  --   successiveMod value iters = foldl (\acc i -> acc % (2^i)) value iters

charToUtf8Bytes : Int -> [Byte]
charToUtf8Bytes codePoint =
  if codePoint < 0 then
    error ("Internal error: negative code point: " <> show codePoint)
  else if codePoint <= 0x7F then
    [codePoint]
  else if codePoint <= 0x7FF then
    let byte1 = 0b11000000 + (codePoint `shiftr` 6) in
    let byte2 = 0b10000000 + (0b111111 & codePoint) in
    [byte1, byte2]
  else if codePoint <= 0xFFFF then
    let byte1 = 0b11100000 + (codePoint `shiftr` 12) in
    let byte2 = 0b10000000 + ((codePoint `shiftr` 6) & 0b111111) in
    let byte3 = 0b10000000 + (codePoint & 0b111111) in
    [byte1, byte2, byte3]
  else if codePoint <= 0x10FFFF then
    let byte1 = 0b11110000 + (codePoint `shiftr` 18) in
    let byte2 = 0b10000000 + ((codePoint `shiftr` 12) & 0b111111) in
    let byte3 = 0b10000000 + ((codePoint `shiftr` 6) & 0b111111) in
    let byte4 = 0b10000000 + (codePoint & 0b111111) in
    [byte1, byte2, byte3, byte4]
  else
    error ("Internal error: out of range code point: " <> show codePoint)

hexes : [Text]
hexes = do
  hexChar <- hexUniChars
  hexChar2 <- hexUniChars
  pure $ TX.fromCodePoints [hexChar, hexChar2]

byteHexMap : Map Byte Text
byteHexMap = Map.fromList (zipChecked byteValues hexes)

byteToHex : Byte -> Text
byteToHex b = O.fromSomeNote ("Internal error: unknown byte value: " <> show b) (Map.lookup b byteHexMap)
