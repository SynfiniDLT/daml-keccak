module Synfini.Keccak.Types where

import DA.Map (Map)
import qualified DA.Optional as O
import qualified DA.Map as Map
import qualified DA.Text as TX

type Vector a = Map Int a

type Matrix a = Vector (Vector a)

size : Vector a -> Int
size = Map.size

listToVector : [a] -> Vector a
listToVector l = Map.fromList (zip [0..length l - 1] l)

vectorToList : Vector a -> [a]
vectorToList = fmap snd . Map.toList

takeVector : Int -> Vector a -> Vector a
takeVector n v = listToVector (fmap snd . take n $ Map.toList v)

dropVector : Int -> Vector a -> Vector a
dropVector n v = listToVector (fmap snd . drop n $ Map.toList v)

concatVectors : [Vector a] -> Vector a
concatVectors vs = listToVector . fmap snd $ concatMap Map.toList vs

updateMatrix : Int -> Int -> a -> Matrix a -> Matrix a
updateMatrix x y v = Map.alter u x
  where
    u None = Some $ Map.fromList [(y, v)]
    u (Some r) = Some $ Map.insert y v r

listToMatrix : [((Int, Int), a)] -> Matrix a
listToMatrix l = foldl addElem Map.empty l
  where
    addElem m ((x, y), value) = Map.alter (addElemInRow y value) x m

    addElemInRow y value None = Some (Map.fromList [(y, value)])
    addElemInRow y value (Some row) = Some (Map.insert y value row)

matrixToList : Matrix a -> [((Int, Int), a)]
matrixToList m = do
  (x, row) <- Map.toList m
  (y, value) <- Map.toList row
  pure ((x, y), value)

(#) : Vector a -> Int -> a
m # k = O.fromSomeNote ("Vector element not found at index: " <> show k) (Map.lookup k m)
infixl 3 #

(##) : Matrix a -> (Int, Int) -> a
m ## (x, y) = (m # x) # y
infixl 3 ##

-- Binary values where the most significant bit is the first element in the list
type Lane = [Bool]

type Byte = Int

zeroLane : Lane
zeroLane = []

pad : Int -> Lane -> Lane
pad n l =
  let lenDiff = length l - n in
  if lenDiff >= 0 then
    drop lenDiff l
  else
    replicate (-lenDiff) False <> l

-- Returns all permutations of bits of length n in ascending order:
-- 0...00, 0...01, 0...10, 00...11, ..., 1...1
bitPermutations : Int -> [Lane]
bitPermutations n | n <= 0 = []
bitPermutations n =
  let p = bitPermutations (n - 1) in
  ((False ::) <$> p) <> ((True ::) <$> p)

nibblePermutations : [Lane]
nibblePermutations = bitPermutations 4

bytePermutations : [Lane]
bytePermutations = bitPermutations 8

hexUniChars : [Int]
hexUniChars = [48..57] <> -- 0 to 9
  [65..70] -- A to F
charBoolMap : Map Int Lane
charBoolMap = Map.fromList (zip hexUniChars nibblePermutations)

byteValues : [Byte]
byteValues = [0..2^7]
byteBoolMap : Map Byte Lane
byteBoolMap = Map.fromList (zip byteValues bytePermutations)

fromHex : Text -> Lane
fromHex =
  concatMap (\char -> O.fromSomeNote ("Not a valid hex character: " <> show char) (Map.lookup char charBoolMap)) .
  TX.toCodePoints

xor : Lane -> Lane -> Lane
l `xor` m =
  let maxLen = max (length l) (length m) in
  zipWith xorBits (pad maxLen l) (pad maxLen m)

  where
    xorBits True False = True
    xorBits False True = True
    xorBits _ _ = False

rol : Lane -> Int -> Int -> Lane
rol l left bits =
  let padded = pad bits l in
  drop left l <> take left l

inv : Lane -> Lane
inv = fmap not

(&) : Lane -> Lane -> Lane
a & b = zipWith (&&) a b

bytesToLane : [Byte] -> Lane
bytesToLane = concatMap (\byte -> O.fromSomeNote ("Not a valid byte: " <> show byte) (Map.lookup byte byteBoolMap))

chunksOf : Int -> [a] -> [[a]]
chunksOf n [] = []
chunksOf n l = take n l :: chunksOf n (drop n l)

laneToBytes : Lane -> Int -> [Byte]
laneToBytes l n =
  bitsToByte <$> chunksOf 8 (pad n l)

  where
    bitsToByte bits = sum $ zipWith (\bit idx -> if bit then 2^idx else 0) bits [7, 6..0]

textToBytes : Text -> Vector Byte
textToBytes = listToVector . TX.toCodePoints

bytesToText : Vector Byte -> Text
bytesToText = TX.fromCodePoints . vectorToList
