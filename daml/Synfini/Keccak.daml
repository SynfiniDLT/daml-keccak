module Synfini.Keccak where

import qualified DA.Action.State.Class as S
import Synfini.Keccak.Types
import DA.Foldable (sequence_, forA_, toList, Foldable, mapA_)
import qualified DA.Action.State as S

bitsToBytes : Int -> Int
bitsToBytes x = (x + 7) / 8

data KeccakSettings = KeccakSettings
  with
    bitrate : Int
    b : Int
    bitrateBytes : Int
    laneW : Int
    outputBits : Int
    -- s : Matrix Lane
    -- buffer : Vector Int

stateW : Int
stateW = 5

rangeW = [0..stateW - 1]

stateH : Int
stateH = 5

rangeH = [0..stateH - 1] 

rangeWH : [(Int, Int)]
rangeWH = do
  x <- rangeW
  y <- rangeH
  pure (x, y)

zero : Matrix Lane
zero = toVector (replicate stateH (toVector (replicate stateW zeroLane)))

mkKeccackSettings : CanAssert a => Int -> Int -> Int -> a KeccakSettings
mkKeccackSettings bitrate b outputBits = do
  assertMsg "Bit rate must be a multiple of 8" (bitrate % 8 == 0)
  assertMsg "b must be a multiple of 25" (b % 25 == 0)
  pure KeccakSettings with
    bitrate
    b
    bitrateBytes = bitsToBytes bitrate
    laneW = b / 25
    outputBits
    -- s = zero
    -- buffer = Map.empty

type KeccakAction a = (Action a, S.ActionState (Matrix Lane) a)

(<--) : KeccakAction a => (Int, Int) -> Lane -> a ()
(x, y) <-- l = S.modify (updateMatrix x y l)
infixl 3 <--

(<--^) : KeccakAction a => (Int, Int) -> Lane -> a ()
(x, y) <--^ u = do
  l <- getLane (x, y)
  (x, y) <-- l `xor` u
infixl 3 <--^

getRow : KeccakAction a => Int -> a (Vector Lane)
getRow r = do
  s <- S.get
  pure (s # r)

getLane : KeccakAction a => (Int, Int) -> a Lane
getLane pos = do
  s <- S.get
  pure (s ## pos)

multiratePadding : Int -> Int -> Vector Byte
multiratePadding usedBytes alignBytes =
  let l = alignBytes - usedBytes in
  let padlen = if l == 0 then alignBytes else l in
  toVector $
    if padlen == 1 then
      []
    else
      []

doKeccak : forall a. KeccakAction a =>
           KeccakSettings ->
           (Int -> Int -> Vector Byte) ->
           (KeccakSettings -> a ()) ->
           Text ->
           a Text
doKeccak ks padfn permfn input = do
  let inputBytes = str2Bytes input
  spongeAbsorb inputBytes
  let finalBuffer : Vector Byte = undefined
  hashBytes <- hashDigest finalBuffer
  pure (bytes2Str hashBytes)

  where
    absorb : Int -> Vector Byte -> a ()
    absorb offset bb = do
      -- if Map.size bb /= ks.bitrateBytes then
      --   error "Bit rate bytes does not match"
      -- else do
      let findInBb idx = if idx >= ks.bitrateBytes then 0 else bb # (idx + offset)

      sequence_ do
        y <- rangeH
        x <- rangeW
        let i = y * stateH + x
        pure do
          (x, y) <--^ bytes2Lane (findInBb <$> [i..i+7])

    hashDigest : Vector Byte -> a (Vector Byte)
    hashDigest buffer = do
      let digestSize = bitsToBytes ks.outputBits
      spongeAbsorbFinal buffer
      spongeSqueeze digestSize

    getBytes : Int -> a (Vector Byte)
    getBytes lim = do
      l <- sequence do
        y <- rangeH
        x <- rangeW
        pure do
          lane <- getLane (x, y)
          pure $ lane2Bytes lane ks.laneW
      pure . toVector . take lim $ concat l

    spongeAbsorb : Vector Byte -> a ()
    spongeAbsorb buffer = do
      --let buffer = str2Bytes str
      forA_ [0,ks.bitrateBytes..(size buffer - ks.bitrateBytes)] $ \offset -> do
        absorb offset buffer
        permfn ks

    spongeAbsorbBlock : Vector Byte -> a ()
    spongeAbsorbBlock bb = do
      absorb 0 bb
      permfn ks

    spongeAbsorbFinal : Vector Byte -> a ()
    spongeAbsorbFinal buffer = do
      let padded = concatVectors [buffer, padfn (size buffer) ks.bitrateBytes]
      spongeAbsorbBlock padded

    spongeSqueeze : Int -> a (Vector Byte)
    spongeSqueeze l = do
      let iters = l / ks.bitrateBytes + (if l % ks.bitrateBytes == 0 then 0 else 1)
      z <- fmap concatVectors . forA [1..iters] $ \_ -> do
        spongeSqueezeOnce
      pure (takeVector l z)

    spongeSqueezeOnce : a (Vector Byte)
    spongeSqueezeOnce = do
      z <- getBytes ks.bitrateBytes
      permfn ks
      pure z

roundConstants : [Lane]
roundConstants = fromHex <$> [
    "0x0000000000000001", "0x0000000000008082", "0x800000000000808A", "0x8000000080008000",
    "0x000000000000808B", "0x0000000080000001", "0x8000000080008081", "0x8000000000008009",
    "0x000000000000008A", "0x0000000000000088", "0x0000000080008009", "0x000000008000000A",
    "0x000000008000808B", "0x800000000000008B", "0x8000000000008089", "0x8000000000008003",
    "0x8000000000008002", "0x8000000000000080", "0x000000000000800A", "0x800000008000000A",
    "0x8000000080008081", "0x8000000000008080", "0x0000000080000001", "0x8000000080008008"
  ]

rotationConstants : Matrix Int
rotationConstants =
  let arr = [
          [  0,  1, 62, 28, 27 ],
          [ 36, 44,  6, 55, 20 ],
          [  3, 10, 43, 25, 39 ],
          [ 41, 45, 15, 21,  8 ],
          [ 18,  2, 61, 56, 14 ]
        ]
  in
  toVector (toVector <$> arr)

reduce : Foldable t => (a -> a -> a) -> t a -> a
reduce f t =
  let l = toList t in
  case l of
    x :: xs -> foldl f x xs
    [] -> error "Unexpected empty list"

keccak_f : KeccakAction a => KeccakSettings -> a ()
keccak_f ks = mapA_ round roundConstants 
  where
    round rc = do
      c : Vector Lane <- fmap toVector . forA rangeH $ \x -> do
        r <- getRow x
        pure $ reduce xor r
      let d : Vector Lane = toVector do
            x <- rangeW
            pure $
              (c # (x - 1) % stateW) `xor`
              (rol (c # (x + 1) % stateW) 1 ks.laneW)
      forA_ rangeWH $ \(x, y) -> do
        (x, y) <--^ (d # x)

      bElems <- forA rangeWH $ \(x, y) -> do
        lane <- getLane (x, y)
        pure (
            (y % stateW, (2 * x + 3 * y) % stateH),
            rol lane (rotationConstants ## (y, x)) ks.laneW
          )
      let b : Matrix Lane = listToMatrix (bElems <> matrixToList zero)

      forA_ rangeWH $ \(x, y) -> do
        (x, y) <-- (b ## (x, y)) `xor`
          ((inv (b ## ((x + 1) % stateW, y))) & (b ## ((x + 2) % stateW, y)))

      (0, 0) <--^ rc

preset : CanAssert a => Int -> Int -> Int -> a (Text -> Text)
preset bitrateBits capacityBits outputBits = do
  let b = bitrateBits + capacityBits
  assertMsg "Must have valid bits" (b `elem` [25, 50, 100, 200, 500, 800, 1600])
  assertMsg "Output bits must be a whole number of bytes" (outputBits % 8 == 0)
  settings <- mkKeccackSettings bitrateBits b outputBits
  pure $ \input -> S.evalState (doKeccak settings multiratePadding keccak_f input) zero
